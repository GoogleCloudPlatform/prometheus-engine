GOCMDS := $(notdir $(patsubst %/,%,$(dir $(shell find cmd -name 'main.go'))))
GOINSTR += $(notdir $(patsubst %/,%,$(dir $(shell find examples/instrumentation -name 'main.go'))))

CLOUDSDK_CONFIG?=${HOME}/.config/gcloud
PROJECT_ID?=$(shell gcloud config get-value core/project)
GMP_CLUSTER?=gmp-test-cluster
GMP_LOCATION?=us-central1-c
API_DIR=pkg/operator/apis

# For now assume the docker daemon is mounted through a unix socket.
# TODO(pintohutch): will this work if using a remote docker over tcp?
DOCKER_HOST?=unix:///var/run/docker.sock
DOCKER_VOLUME:=$(DOCKER_HOST:unix://%=%)

IMAGE_REGISTRY?=gcr.io/$(PROJECT_ID)/prometheus-engine
TAG_NAME?=$(shell date "+gmp-%Y%d%m_%H%M")

# TODO(TheSpiritXIII): Temporary env variables part of `export.go` unit tests.
export TEST_TAG=true

# Support gsed on OSX (installed via brew), falling back to sed. On Linux
# systems gsed won't be installed, so will use sed as expected.
SED ?= $(shell which gsed 2>/dev/null || which sed)

# TODO(pintohutch): this is a bit hacky, but can be useful when testing.
# Ultimately this should be replaced with go templating.
define update_manifests
	find manifests examples cmd/operator/deploy -type f -name "*.yaml" -exec sed -i "s#image: .*/$(1):.*#image: ${IMAGE_REGISTRY}/$(1):${TAG_NAME}#g" {} \;
endef

define docker_build
	DOCKER_BUILDKIT=1 docker build $(1)
endef

define docker_tag_push
	docker tag $(1) $(2)
	docker push $(2)
endef

.PHONY: help
help:        ## Show this help.
             ##
	@fgrep -h "##" $(MAKEFILE_LIST) | fgrep -v fgrep | sed -e 's/\\$$//' | sed -e 's/##//'

.PHONY: clean
clean:       ## Clean build time resources, primarily, unused docker images.
             ##
	for i in `docker images | grep -E '^gmp/|.*/prometheus-engine/.*' | awk '{print $$3}' | uniq`; do docker image rm -f $$i; done

.PHONY: lint
lint:        ## Lint code.
             ##
	@echo ">> linting code"
	DOCKER_BUILDKIT=1 docker run --rm -v $(shell pwd):/app -w /app golangci/golangci-lint:v1.54.2 golangci-lint run -v --timeout=5m

$(GOCMDS):   ## Build go binary from cmd/ (e.g. 'operator').
             ## The following env variables configure the build, and are mutually exclusive:
             ## Set NO_DOCKER=1 to build natively without Docker.
             ## Set DOCKER_PUSH=1 to tag image with TAG_NAME and push to IMAGE_REGISTRY.
             ## Set CLOUD_BUILD=1 to build the image on Cloud Build, with multi-arch support.
             ## By default, IMAGE_REGISTRY=gcr.io/PROJECT_ID/prometheus-engine.
             ##
	$(MAKE) bin-go BIN_GO_NAME="$@" BIN_GO_DIR="cmd"

$(GOINSTR):  ## Build go binary from examples/instrumentation/ (e.g. 'go-synthetic').
             ## The following env variables configure the build, and are mutually exclusive:
             ## Set NO_DOCKER=1 to build natively without Docker.
             ## Set DOCKER_PUSH=1 to tag image with TAG_NAME and push to IMAGE_REGISTRY.
             ## Set CLOUD_BUILD=1 to build the image on Cloud Build, with multi-arch support.
             ## By default, IMAGE_REGISTRY=gcr.io/PROJECT_ID/prometheus-engine.
             ##
	$(MAKE) bin-go BIN_GO_NAME="$@" BIN_GO_DIR="examples/instrumentation"

BIN_GO_NAME =
BIN_GO_DIR =
bin-go:
	@echo ">> building binaries"
ifeq ($(NO_DOCKER), 1)
	if [ "$(BIN_GO_NAME)" = "frontend" ]; then pkg/ui/build.sh; fi
	CGO_ENABLED=0 go build -tags builtinassets -mod=vendor -o ./build/bin/$(BIN_GO_NAME) ./$(BIN_GO_DIR)/$(BIN_GO_NAME)/*.go
# If pushing, build and tag native arch image to GCR.
else ifeq ($(DOCKER_PUSH), 1)
	$(call docker_build, --tag gmp/$(BIN_GO_NAME) -f ./$(BIN_GO_DIR)/$(BIN_GO_NAME)/Dockerfile .)
	@echo ">> tagging and pushing images"
	$(call docker_tag_push,gmp/$(BIN_GO_NAME),${IMAGE_REGISTRY}/$(BIN_GO_NAME):${TAG_NAME})
	@echo ">> updating manifests with pushed images"
	$(call update_manifests,$(BIN_GO_NAME))
# Run on cloudbuild and tag multi-arch image to GCR.
# TODO(pintohutch): cache source tarball between binary builds?
else ifeq ($(CLOUD_BUILD), 1)
	@echo ">> building GMP images on Cloud Build with tag: $(TAG_NAME)"
	gcloud builds submit --config build.yaml --timeout=30m --substitutions=_IMAGE_REGISTRY=$(IMAGE_REGISTRY),_IMAGE=$(BIN_GO_NAME),TAG_NAME=$(TAG_NAME) --async
	$(call update_manifests,$(BIN_GO_NAME))
# Just build it locally.
else
	$(call docker_build, --tag gmp/$(BIN_GO_NAME) -f ./$(BIN_GO_DIR)/$(BIN_GO_NAME)/Dockerfile .)
endif

bin:         ## Build all go binaries from cmd/ and examples/instrumentation/.
             ## All env vars from $(GOCMDS) work here as well.
             ##
bin: $(GOCMDS) $(GOINSTR)

.PHONY: regen
regen:       ## Refresh autogenerated files and reformat code.
             ## Use CHECK=1 to only validate clean repo after run.
             ##
regen:
ifeq ($(CHECK), 1)
	$(call docker_build, -f ./hack/Dockerfile --target hermetic -t gmp/hermetic \
		--build-arg RUNCMD='./hack/presubmit.sh all diff' .)
else
	$(call docker_build, -f ./hack/Dockerfile --target sync -o . -t gmp/sync \
		--build-arg RUNCMD='./hack/presubmit.sh all' .)
	rm -rf vendor && mv vendor.tmp vendor
endif

.PHONY: test
test:        ## Run unit tests. Setting NO_DOCKER=1 runs test on host machine.
             ##
	@echo ">> running unit tests"
ifeq ($(NO_DOCKER), 1)
	go test `go list ./... | grep -v e2e | grep -v export/bench | grep -v export/gcm`
else
	# TODO(TheSpiritXIII): Temporary env variables part of `export.go` unit tests.
	$(call docker_build, -f ./hack/Dockerfile --target sync -o . -t gmp/hermetic \
		--build-arg RUNCMD='GIT_TAG="$(shell git describe --tags --abbrev=0)" TEST_TAG=true ./hack/presubmit.sh test' .)
	rm -rf vendor.tmp
endif

GCM_SECRET?=''
.PHONY: test-export-gcm
test-export-gcm:  ## Run export unit tests that will use GCM if GCM_SECRET is present.
                  ## TODO(bwplotka): Move to cloud build.
ifneq ($(GCM_SECRET), '')
	TEST_TAG=false go test -v ./pkg/export/gcm
else
	@echo "Secret not provided, skipping!"
endif

.PHONY: e2e
e2e:         ## Run e2e test suite against fresh kind k8s cluster. By default it
             ## deploys and uses single-node kind cluster (left up after the tests). Setting
             ## NO_DOCKER=1 execute tests from the host machine assuming kubectl
             ## is already configured against the Kubernetes cluster of your choice.
             ##
             ## Setting NO_DOCKER=1 also writes real data to GCM API under $PROJECT_ID
             # environment variable. Use $GMP_CLUSTER, $GMP_LOCATION to specify
             ## timeseries labels.
             ##
ifeq ($(NO_DOCKER), 1)
	@echo ">> running e2e against your cluster"
	kubectl apply -f manifests/setup.yaml
	kubectl apply -f cmd/operator/deploy/operator/01-priority-class.yaml
	kubectl apply -f cmd/operator/deploy/operator/03-role.yaml
	go test -v "./e2e/..." -run "$(or $(TEST_RUN), .)" -args -project-id="$(PROJECT_ID)" -cluster="$(GMP_CLUSTER)" -location="$(GMP_LOCATION)" $(TEST_ARGS)
else
	@echo ">> building kindtest image"
	$(call docker_build, -f hack/Dockerfile --target kindtest -t gmp/kindtest .)
	@echo ">> running container"
# We lose some isolation by sharing the host network with the kind containers.
# However, we avoid a gcloud-shell "Dockerception" and save on build times.
	docker run --env TEST_RUN="$(TEST_RUN)" --env TEST_ARGS="$(TEST_ARGS)" --network host --rm -v $(DOCKER_VOLUME):/var/run/docker.sock gmp/kindtest ./hack/kind-test.sh
endif

.PHONY: presubmit
presubmit:   ## Regenerate all resources, build all images and run all tests.
             ## Steps from presubmit are validated on the CI, but feel free to
             ## run it if you see CI failures related to regenerating resources
             ## or when you want to do local check before submitting.
             ##
             ## Use `CHECK=1` to fail the command if repo state is not clean
             ## after presubmit (might require committing the changes).
             ##
presubmit: updateversions regen bin test e2e

.PHONY: updateversions
CURRENT_TAG = v0.7.4-gke.0
CURRENT_PROM_TAG = v2.41.0-gmp.4-gke.1
CURRENT_AM_TAG = v0.25.1-gmp.0-gke.1
LABEL_API_VERSION = 0.7.4
FILES_TO_UPDATE = $(shell find . -type f -name "*.yaml" ! -name "kube-state-metrics.yaml" ! -name "node-exporter.yaml")
updateversions: ## Modify all manifests, so it contains the expected versions.
                ##
                ## TODO(bwplotka): CI does not check updateversions--add that there.
                ## Also, consider moving updateversion to hack/presubmit.sh for
                ## consistency.
                ##
updateversions: $(SED)
	@echo ">> Updating prometheus-engine images in manifests to $(CURRENT_TAG)"
	@$(SED) -i -r 's#image: gke.gcr.io/prometheus-engine/(.*):.*#image: gke.gcr.io/prometheus-engine/\1:$(CURRENT_TAG)#g' $(FILES_TO_UPDATE) # This will match all, but Prom and AM will be fixed below.
	@echo ">> Updating prometheus images in manifests to $(CURRENT_PROM_TAG)"
	@$(SED) -i -r 's#image: gke.gcr.io/prometheus-engine/prometheus:.*#image: gke.gcr.io/prometheus-engine/prometheus:$(CURRENT_PROM_TAG)#g' $(FILES_TO_UPDATE)
	@echo ">> Updating alertmanager images in manifests to $(CURRENT_AM_TAG)"
	@$(SED) -i -r 's#image: gke.gcr.io/prometheus-engine/alertmanager:.*#image: gke.gcr.io/prometheus-engine/alertmanager:$(CURRENT_AM_TAG)#g' $(FILES_TO_UPDATE)
	@echo ">> Updating app.kubernetes.io/version to $(LABEL_API_VERSION)"
	@$(SED) -i -r 's#app.kubernetes.io/version: .*#app.kubernetes.io/version: $(LABEL_API_VERSION)#g' $(FILES_TO_UPDATE)
	@echo ">> Updating constant in export.go to $(LABEL_API_VERSION)"
	@$(SED) -i -r 's#	Version    = .*#	Version    = "$(LABEL_API_VERSION)"#g' pkg/export/export.go

