{"version":3,"sources":["../src/componentWithName.js"],"names":["stripHOCs","fullName","namesOfHOCsToStrip","innerName","test","HOC","previousHOC","replace","indexOf","RegExp","hasName","name","propValue","propName","componentName","rest","Array","isArray","map","item","Boolean","React","isValidElement","TypeError","type","componentNameFromType","innerComponentName","length","componentWithName","options","passedOptions","Object","keys","join","allHOCNamesAreValid","every","x","componentWithNameValidator","props","isRequired","componentWithNameRequired"],"mappings":"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","sourcesContent":["import React from 'react';\nimport isRegex from 'is-regex';\nimport find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  let innerName = fullName;\n  while ((/\\([^()]*\\)/g).test(innerName)) {\n    let HOC = innerName;\n    let previousHOC;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp(`^${HOC}\\\\(|\\\\)$`, 'g'), '');\n  }\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest) {\n  if (Array.isArray(propValue)) {\n    return find(\n      propValue.map((item) => hasName(\n        name,\n        namesOfHOCsToStrip,\n        item,\n        propName,\n        componentName,\n        ...rest,\n      )),\n      Boolean,\n    ) || null;\n  }\n\n  if (!React.isValidElement(propValue)) {\n    return new TypeError(\n      `${componentName}.${propName} is not a valid React element`,\n    );\n  }\n\n  const { type } = propValue;\n  const componentNameFromType = getComponentName(type);\n  const innerComponentName = namesOfHOCsToStrip.length > 0\n    ? stripHOCs(componentNameFromType, namesOfHOCsToStrip)\n    : componentNameFromType;\n\n  if (isRegex(name) && !name.test(innerComponentName)) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components matching the regular expression ${name}`,\n    );\n  }\n\n  if (!isRegex(name) && innerComponentName !== name) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components named ${name}, got ${innerComponentName}`,\n    );\n  }\n\n  return null;\n}\n\nexport default function componentWithName(\n  name,\n  options = {},\n) {\n  if (typeof name !== 'string' && !isRegex(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  const passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || (passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs')) {\n    throw new TypeError(`The only options supported are: “stripHOCs”, got: “${passedOptions.join('”, “')}”`);\n  }\n  const { stripHOCs: namesOfHOCsToStrip = [] } = options;\n\n  const allHOCNamesAreValid = namesOfHOCsToStrip.every((x) => {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (props[propName] == null) {\n      return null;\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const { [propName]: propValue } = props;\n    if (propValue == null) {\n      return new TypeError(`\\`${componentName}.${propName}\\` requires at least one component named ${name}`);\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(componentWithNameValidator, `componentWithName:${name}`, name);\n}\n"],"file":"componentWithName.js"}