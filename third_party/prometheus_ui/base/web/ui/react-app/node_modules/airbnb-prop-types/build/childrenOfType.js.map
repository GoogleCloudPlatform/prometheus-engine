{"version":3,"sources":["../src/childrenOfType.js"],"names":["onlyTypes","types","children","componentName","every","child","Type","type","typeNames","map","getComponentName","join","TypeError","isRequired","length","childrenOfType","validator","props","propName"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;AAEA,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAAmD;AACjD,MAAI,CAACD,QAAQ,CAACE,KAAT,CAAe,UAACC,KAAD;AAAA,WAAWA,KAAK,IAAI,gCAAKJ,KAAL,EAAY,UAACK,IAAD;AAAA,aAAUA,IAAI,KAAK,GAAT,IAAgBD,KAAK,CAACE,IAAN,KAAeD,IAAzC;AAAA,KAAZ,CAApB;AAAA,GAAf,CAAL,EAAqG;AACnG,QAAME,SAAS,GAAGP,KAAK,CAACQ,GAAN,CAAUC,4BAAV,EAA4BC,IAA5B,CAAiC,OAAjC,CAAlB;AACA,WAAO,IAAIC,SAAJ,YACAT,aADA,6CACiDK,SADjD,EAAP;AAGD;;AACD,SAAO,IAAP;AACD;;AAED,SAASK,UAAT,CAAoBZ,KAApB,EAA2BC,QAA3B,EAAqCC,aAArC,EAAoD;AAClD,MAAID,QAAQ,CAACY,MAAT,KAAoB,CAAxB,EAA2B;AACzB,QAAMN,SAAS,GAAGP,KAAK,CAACQ,GAAN,CAAUC,4BAAV,EAA4BC,IAA5B,CAAiC,OAAjC,CAAlB;AACA,WAAO,IAAIC,SAAJ,YAAmBT,aAAnB,kDAAyEK,SAAzE,EAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASO,cAAT,GAAkC;AAAA,oCAAPd,KAAO;AAAPA,IAAAA,KAAO;AAAA;;AAChC,MAAIA,KAAK,CAACa,MAAN,GAAe,CAAnB,EAAsB;AACpB,UAAM,IAAIF,SAAJ,CAAc,6CAAd,CAAN;AACD;;AAED,WAASI,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCf,aAApC,EAAmD;AACjD,WAAOH,SAAS,CAACC,KAAD,EAAQ,oCAAmBgB,KAAK,CAACC,QAAD,CAAxB,CAAR,EAA6Cf,aAA7C,CAAhB;AACD;;AAEDa,EAAAA,SAAS,CAACH,UAAV,GAAuB,UAACI,KAAD,EAAQC,QAAR,EAAkBf,aAAlB,EAAoC;AACzD,QAAMD,QAAQ,GAAG,oCAAmBe,KAAK,CAACC,QAAD,CAAxB,CAAjB;AACA,WAAOL,UAAU,CAACZ,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAAV,IAA8CH,SAAS,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAA9D;AACD,GAHD;;AAKA,SAAO,+BAAca,SAAd,EAAyB,gBAAzB,EAA2Cf,KAA3C,CAAP;AACD;;eAEcc,c","sourcesContent":["import find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport renderableChildren from './helpers/renderableChildren';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every((child) => child && find(types, (Type) => Type === '*' || child.type === Type))) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(\n      `\\`${componentName}\\` only accepts children of type ${typeNames}`,\n    );\n  }\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(`\\`${componentName}\\` requires at least one node of type ${typeNames}`);\n  }\n  return null;\n}\n\nfunction childrenOfType(...types) {\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, renderableChildren(props[propName]), componentName);\n  }\n\n  validator.isRequired = (props, propName, componentName) => {\n    const children = renderableChildren(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return wrapValidator(validator, 'childrenOfType', types);\n}\n\nexport default childrenOfType;\n"],"file":"childrenOfType.js"}