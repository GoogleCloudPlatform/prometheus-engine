{"version":3,"sources":["../src/or.js"],"names":["oneOfTypeValidator","validators","validator","oneOfType","props","propName","componentName","rest","propValue","errors","map","v","filter","Boolean","length","TypeError","isRequired","oneOfTypeRequired","or","name","Array","isArray","RangeError"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;AAEA,SAASA,kBAAT,CAA4BC,UAA5B,EAAwC;AACtC,MAAMC,SAAS,GAAG,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAA4D;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAAA,QACxDC,SADwD,GAC1CJ,KAD0C,CACnEC,QADmE;;AAE5E,QAAI,OAAOG,SAAP,KAAqB,WAAzB,EAAsC;AACpC,aAAO,IAAP;AACD;;AAED,QAAMC,MAAM,GAAGR,UAAU,CACtBS,GADY,CACR,UAACC,CAAD;AAAA,aAAOA,CAAC,MAAD,UAAEP,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAP;AAAA,KADQ,EAEZK,MAFY,CAELC,OAFK,CAAf;;AAIA,QAAIJ,MAAM,CAACK,MAAP,GAAgBb,UAAU,CAACa,MAA/B,EAAuC;AACrC,aAAO,IAAP;AACD;;AACD,WAAO,IAAIC,SAAJ,WAAiBT,aAAjB,yCAA6DD,QAA7D,OAAP;AACD,GAdD;;AAeAH,EAAAA,SAAS,CAACc,UAAV,GAAuB,SAASC,iBAAT,CAA2Bb,KAA3B,EAAkCC,QAAlC,EAA4CC,aAA5C,EAAoE;AAAA,uCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAAA,QACrEC,SADqE,GACvDJ,KADuD,CAChFC,QADgF;;AAEzF,QAAI,OAAOG,SAAP,KAAqB,WAAzB,EAAsC;AACpC,aAAO,IAAIO,SAAJ,WAAiBT,aAAjB,0CAA8DD,QAA9D,OAAP;AACD;;AAED,QAAMI,MAAM,GAAGR,UAAU,CACtBS,GADY,CACR,UAACC,CAAD;AAAA,aAAOA,CAAC,MAAD,UAAEP,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAP;AAAA,KADQ,EAEZK,MAFY,CAELC,OAFK,CAAf;;AAIA,QAAIJ,MAAM,CAACK,MAAP,KAAkBb,UAAU,CAACa,MAAjC,EAAyC;AACvC,aAAO,IAAIC,SAAJ,WAAiBT,aAAjB,6BAAiDG,MAAjD,mCAAgFJ,QAAhF,OAAP;AACD;;AACD,WAAO,IAAP;AACD,GAdD;;AAeA,SAAO,+BAAcH,SAAd,EAAyB,WAAzB,EAAsCD,UAAtC,CAAP;AACD;;AAEc,SAASiB,EAAT,CAAYjB,UAAZ,EAAqC;AAAA,MAAbkB,IAAa,uEAAN,IAAM;;AAClD,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcpB,UAAd,CAAL,EAAgC;AAC9B,UAAM,IAAIc,SAAJ,CAAc,uCAAd,CAAN;AACD;;AACD,MAAId,UAAU,CAACa,MAAX,IAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIQ,UAAJ,CAAe,uCAAf,CAAN;AACD;;AAED,MAAMpB,SAAS,GAAGF,kBAAkB,EAClC,wBAAQA,kBAAkB,CAACC,UAAD,CAA1B,CADkC,4BAE/BA,UAF+B,GAApC;AAKA,SAAO,+BAAcC,SAAd,EAAyBiB,IAAzB,EAA+BlB,UAA/B,CAAP;AACD","sourcesContent":["import { arrayOf } from 'prop-types';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction oneOfTypeValidator(validators) {\n  const validator = function oneOfType(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue === 'undefined') {\n      return null;\n    }\n\n    const errors = validators\n      .map((v) => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length < validators.length) {\n      return null;\n    }\n    return new TypeError(`${componentName}: invalid value supplied to ${propName}.`);\n  };\n  validator.isRequired = function oneOfTypeRequired(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue === 'undefined') {\n      return new TypeError(`${componentName}: missing value for required ${propName}.`);\n    }\n\n    const errors = validators\n      .map((v) => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length === validators.length) {\n      return new TypeError(`${componentName}: invalid value ${errors} supplied to required ${propName}.`);\n    }\n    return null;\n  };\n  return wrapValidator(validator, 'oneOfType', validators);\n}\n\nexport default function or(validators, name = 'or') {\n  if (!Array.isArray(validators)) {\n    throw new TypeError('or: 2 or more validators are required');\n  }\n  if (validators.length <= 1) {\n    throw new RangeError('or: 2 or more validators are required');\n  }\n\n  const validator = oneOfTypeValidator([\n    arrayOf(oneOfTypeValidator(validators)),\n    ...validators,\n  ]);\n\n  return wrapValidator(validator, name, validators);\n}\n"],"file":"or.js"}