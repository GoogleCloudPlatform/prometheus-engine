{"version":3,"names":["transpileEnum","path","t","node","declare","remove","name","id","fill","enumFill","parent","type","insertAfter","seen","parentPath","isGlobal","isProgram","scope","registerDeclaration","replaceWith","makeVar","Error","isExportDeclaration","getData","setData","kind","variableDeclaration","variableDeclarator","buildEnumWrapper","template","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","cloneNode","NAME","VALUE","ID","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializer","evaluate","undefined","set","numericLiteral","assert","stringLiteral","initializerPath","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","evalConstant","evalUnaryExpression","evalBinaryExpression","expression","quasis","length","cooked","argument","operator","left","right"],"sources":["../src/enum.ts"],"sourcesContent":["import { template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\nimport assert from \"assert\";\n\ntype t = typeof t;\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      path.insertAfter(fill);\n      if (seen(path.parentPath)) {\n        path.remove();\n      } else {\n        const isGlobal = t.isProgram(path.parent); // && !path.parent.body.some(t.isModuleDeclaration);\n        path.scope.registerDeclaration(\n          path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0],\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id: t.Identifier, t: t, kind: \"var\" | \"let\" | \"const\") {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = template(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments,\n  });\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n): Array<[name: string, value: t.Expression]> {\n  const seen: PreviousEnumMembers = new Map();\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n\n  return path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value: t.Expression;\n    if (initializer) {\n      constValue = evaluate(initializer, seen);\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          assert(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        const initializerPath = memberPath.get(\"initializer\");\n\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path,\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path });\n        }\n\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n      const lastRef = t.memberExpression(\n        t.cloneNode(path.node.id),\n        t.stringLiteral(lastName),\n        true,\n      );\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n\n    lastName = name;\n    return [name, value];\n  });\n}\n\n// Based on the TypeScript repository's `evalConstant` in `checker.ts`.\nfunction evaluate(\n  expr: t.Node,\n  seen: PreviousEnumMembers,\n): number | string | typeof undefined {\n  return evalConstant(expr);\n\n  function evalConstant(expr: t.Node): number | typeof undefined {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n      case \"Identifier\":\n        return seen.get(expr.name);\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n      /* falls through */\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator,\n  }: t.UnaryExpression): number | typeof undefined {\n    const value = evalConstant(argument);\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr: t.BinaryExpression): number | undefined {\n    const left = evalConstant(expr.left);\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evalConstant(expr.right);\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      default:\n        return undefined;\n    }\n  }\n}\n"],"mappings":"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"}